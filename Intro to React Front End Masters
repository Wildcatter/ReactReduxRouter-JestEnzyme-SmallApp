Intro to React Front End Masters

------- YARN -----
1) npm install --save react = yarn add react
2) npm install --global yarn
3) Then just "yarn" to install package.json
4) Yarn a lot of cool features
5) Can update interatively, checks for all new updates for your dependencies


------------- UNDERSTANDING REACT -------
1) Don't need any tooling to write React
2) Just a library that has function calls to produce markup
3) Begin just by thinking of it as 'View' in MVC.
4) React came about for easy to follow code flows, easier to debug
5) Built on top of Request/Response cycle
6) Stuff all code into little pieces so you know where to look
7) Bring all the little pieces together to make a bigger app


--------------- MY FIRST COMPONENT---------
1) Write in React, have browser, React DOM acts as glue
2) Can use script tags for react and react DOM

<script src="node_modules/react/dist/react.js"></script>
	<script src="node_modules/react-dom/dist/react-dom.js"></script>

3) Then can just put our first component in another script tag

<script>
		var myFirstComponent = React.createClass({
			render: function() {
				return (
					React.DOM.div(null,
						React.DOM.h1(null, 'This is my first component!')
					)
				)
			}
		})
	</script>

4) The null is where you'd pass attributes like class
5) Just creating DOM elements


----------- createClass vs createElement -------
1) createClass = creating blueprint for new type of component
2) Think of it as a new stamp that you can render as many as you want
3) createElement = just one stamp, just one instance of particular new element

ReactDOM.render(React.createElement(myFirstComponent), document.getElementById('app'))

4) Components in React are NOTHING BUT FUNCTIONS


--------------- MY SECOND COMPONENT ---------------
1) EVERY COMPONENT MUST HAVE A RENDER METHOD
2) And it must ALWAYS RETURN MARKUP!
3) Render must be a pure function


--------- FACTORIES AND PROPS ---------
1) Factory method

var myTitleFactory = React.createFactory(myTitle)

2) With passing down props, can pass down just strong or CSS attributes. With CSS attributes, you create a style object

Pass down props from this

myTitleFactory({ title: 'nananana', color: 'peru'})

to this

h1({ style: { color: this.props.color, fontWeight: 'bold' } }, this.props.title)


------------------ USING STANDARD ------------
1) Kinda cool OT, using GO there's just a standard styling guide everyone uses
2) Standard will flag REACT stuff undefined so just use a comment at top of project

/* global React ReactDOM */


----------- NPM SCRIPTS -----------
1) Nada


---------- WEBPACK AND ES6 MODULES ---------
1) Will be using Webpack 2 and Babel
2) Webpack = takes all modules you create and puts them in one file, BUNDLES
3) Webpack has loaders, basically like a middle processing feature
4) Set entry file point and 'exit' file in webpack

webpack js/ClientApp.js public/bundle.js

5) 724kb, unminified. Can use production mode with

NODE_ENV=production webpack -p js/ClientApp.js public/bundle.js

6) Now 148kb. Still not gzipped. Want to stay in debugged version for now though, gives much better error messages.



--------- BABEL CONFIGURATION ---------
1) Babel takes future JS and compiles it to run in every browser
2) Now transforms different types of code into other code. Like JSX
3) Used in production for a ton of companies, Netflix, Reddit, almost all SV companies
4) Doesn't ship with any configuration, can't do anything until you give it plugins and configuration
5) Must make a new file called ".babelrc" in root directory. Start with this

{
	"presets": [
	  "react",
	  ["es2015", {"modules": false, "loose": true}]
	]
}

6) Babel has 2 concepts: Plugin and preset. Preset = just a group of plugins
7) es2015 = transform from es6 to es5, plugins for generators, arrow functions, let and const, etc.
8) NOT OKAY FOR PRODUCTION (react is okay for production), includes a lot of polyfills + extra code to get it working. Want production bundles as small as possible
9) react = just the JSX transformation to make readable in ES5
10) When giving preset an array, basically giving it options. Want webpack to take care of modules (import statements too), for "tree shaking"
11) "Tree shaking" deals with live code inclusion, only includes code that's going to be run
12) loose = leaves out crazy edge cases and just includes fast/smaller polyfills.
13) Webpack includes Uglify, goes through and wipes all the code not used, concatenates, etc.



------ CREATING A webpack.config.js FILE-------------
1) Go into bash and type

webpack --module-bind='js=babel' js/ClientApp.js public/bundle.js

2) This is just saying anytime you come across a JS file, just go ahead and run through Babel
3) Babel specifically runs a Babel loader, a loader in Webpack is kind of just a plugin is just a middle transform to run it through
4) Create new file called webpack.config.js in your root directory
5) Require path and make a module.exports object
6) context: __dirname basically just tells Node that whenever running, go to root directory
7) entry: is just entrypoint for app, ClientApp.js
8) devtool: we'll use 'eval'
9) Now an output property that has an object called path:, which is just where we want the bundle to go.
10) Also in the output a filename:, called bundle.js
11) Now a another resolve property and it's an object, using extensions:, we'll use .js and .json files. Checks extensions for files to use
12) DON'T USE DEVTOOLS FOR PRODUCTION BUILDS!!
13) Now a stats property that's an object, this is basically what Webpack reports on. we'll report on colors, reasons, and chunks all set to true.
14) Lastly we have a module property that's an object, and it has a rules property that's an array. Basically if files meet these rules then run them.
15) The rules array contains a series of objects for your rules. We'll use a new object with a property of test:, and in that test we'll use RegEx to test for .js files.

test: /\.js$/

16) Now a second property called loader:, so if it passes the test run it through the 'babel-loader'
17) Now you can just type "webpack" and it will run correctly WOOT


------- RUNNING WEBPACK FROM NPM-----
1) In package.json add another script

"build": "webpack"




------------- JSX --------
1) XML like syntax, was started at Facebook mainly for PHP development
2) Going to modify MyTitle.js into JSX


var MyTitle = React.createClass({
  render: function () {
  	const style = {color: this.props.color}
    return (
      <div>
      	<h1 style= { style }>
      		{this.props.title}
      	</h1>
      </div>
    )
  }
})

3) Now have everything all mashed together in one file. Ever have problems exactly one place to start looking.
4) Go ahead and put watch in package.json as a script

"watch": "npm run build -- --watch"



--------- JSX vs. createElement --------
1) <div> in JSX/React gets compiled to React.createElement('div', null, )
2) Components have to be uppercase
3) lowercase = LITERALLY going to be put on the DOM, so <divs> literally puts a div on the DOM.
4) With components, just being reduced to function calls
5) Why can't you have two siblings be a top level component, ie. TWO top level divs? HAVE TO RETURN EXACTLY ONE THING!!! One top level div


------ CONFIGURING CSS IMPORTS ----
1) Add another rule to webpack config

{
	test: /\.css$/,
	use: [
		'style-loader',
		{
			loader: 'css-loader',
			options: {
						url: false
					}
		}
	]
}

2) Separate CSS, bundles CSS into bundle.js. Typically not a great idea because CSS styles will load with JS instead of before.
3) Typically want CSS to load before


-------IMPORT CSS IN REACT--------
1) Delete everything in ClientApp.js and start over
2) import React, { render } from react-dom, and the normalize + style css files
3) Make a normal component called App and render it


-------- LINT RULES FOR REACT ------
1) Standard doesn't really come prepackaged with rules for React so we prob need to make some
2) Since Standard not configurable, need to modify ESLint with Standard rules
3) Make a new file called ".eslintrc.json"

{
	"extends": ["standard", "standard-react"]
}

4) Need Lint to run via ESLint directly. Go into package.json and fix script

"lint": "eslint js/**/*.js webpack.config.js"

5) ESLint searches for node_modules for ESLint then searches globally.
6) npm run lint -s to check for errors
7) npm run lint -s -- --fix to fix
8) Delete MyTitle.js, don't need it anymore


--------- AUTOMATED LINTING -----
1) Cool for linter to run when it's changed
2) Go into webpack config and make a new rule

{
    enforce: 'pre',
    test: /\.js$/,
    loader: 'eslint-loader',
    exclude: /node_modules/
 },

3) enforce pre is how you did preloaders in webpack 1, synonymous concept



---------- WEBPACK DEVELOPMENT SERVER ------
1) Just as a top level property put

devServer: {
  	publicPath: '/public'
 }

 2) Just identifying static directory for Webpack.
 3) Now go back to package.json and put this script

  "dev": "webpack-dev-server",

 4) npm run dev
 5) Now go to localhost:8080 and youll get page.



------------- ROUTING IN REACT -----------
1) Make a new landing component
2) Basically include all the stuff under the div landing from before
3) Now in ClientApp import HashRouter, Match from react router, then your landing component
4) Now include <Hashrouter> as your parent element in your return statement for App
5) In the app div, type

<div className='app'>
   <Match exactly pattern='/' component={Landing} />
</div>



--------- HASHROUTER CONFIGURATION -------
1) Higher Order Component = no display of its own, just encapsulates behavior. That's why HashRouter is here
2) Match is also a HOC, or "behavior oriented components"
3) HashRouter typically root component
4) Everything inside HashRouter displayed
5) Basically HashRouter is for client-side routes?? something
6) TRY TO AVOID USING HASHROUTER
7) NO REASON TO USE WITH NODE ESPECIALLY. NODE CAN CONSUME REACT ROUTER ROUTES


-------- CREATING THE SEARCH PAGE ROUTE -----
1) Create new file called Search.js
2) Just create a simple component with an h1
3) In ClientApp set up the route

<Match pattern='/search' component={Search} />

4) So we're going to use BrowserRouter
5) Go into webpack config and put this in devServer

historyApiFallback: true

6) Go into ClientApp and change all HashRouter to BrowserRouter
7) SIDENOTE: React Router still works in React Native!!!!
8) In Landing import { Link } from react-router
9) Then in Landing add Link tag

<Link to='/search'> or Browse All</Link>



---------- LOADING JSON FILES -----------
1) In webpack config add json and json loader

{
  test: /\.json$/,
  loader: 'json-loader'
}

2) Use pre filled data.json in public folder, import it into Search
3) Can use a bit of a hack

<pre><code>{JSON.stringify(preload, null, 4)}</code></pre>

4) <pre><code> is a neat hack


---------- ITERATING THROUGH DATA -------------
1) Want to make markup for each title in data.json
2) Want to MAP
3) Map takes a function and applies it to each individual element inside array

{preload.shows.map(function (show) {
   return (
       <h3>{show.title}</h3>
   )

4) Now use ES6 arrow

 {preload.shows.map((show) => {



-------- CREATING SHOWCARD COMPONENT --------
1) Let's make it cooler, use posters with template strings

<img src={`/public/img/posters/${show.poster}`} />

2) Now full card

<div className='show-card'>
     <img src={`/public/img/posters/${show.poster}`} />
       <div>
          <h3>{show.title}</h3>
           <h4>({show.year})</h4>
           <p>{show.description}</p>
        </div>
 </div>

 3) If you're doing a lot of markup, usually want to put into separate component
 4) This map needs to be in another component
 5) Make new component called ShowCard and move everything returned by the map function into it
 6) Change all of "show" into "this.props.show"
7) BUT, now you can DESTRUCTURE

const { poster, title, year, description } = this.props.show

8) And just use the regular names as before
9) Basically saying INSIDE SHOW OBJECT, has those parameters and pull them out
10) Now put component in Search.js

<ShowCard show={show} />


------------------ KEY PROP ---------
1)  Need to give them keys just to help organize/diffing and shit

<ShowCard key={show.imdbID} show={show} />

2) Could use title if they didn't have id


------------ PROPTYPES ------------
1) pull string from react proptypes in ShowCard.js

const { string } = React.PropTypes

2) In component, set a propTypes property. This is basically just saying what you expect to get from the parent component
3) shape = just an object with properties named
4) PropTypes is totally optional
5) Why PropTypes are good, when someone reads it, knows exactly what to use
6) In Production React does not check PropTypes, just check in development


--------- USING THE SPREAD OPERATOR IN JSX ---------
1) Go to Search.js

<ShowCard key={show.imdbID} {...show} />

2) Mimics spread operator, take all properties in show and spread them out like you declared each one individually.
3) Go to ShowCard

change the const in render to just = this.props
now propTypes don't need a show, they're already declared as is

4) Typically better, less nesting almost always better when it comes to propTypes


------------------- MANAGING STATE --------------
1) Only thing that modify the state of a component is THE COMPONENT ITSELF!
2) Data only flows DOWN = one way data flow
3) What if there's data in ShowCard that you need in Search? You take the data out of ShowCard and you put in Search and pass down. No way to push to siblings.
4) What if you have a button or something that needs to modify parent, like a form? Pass function to child with data, and it modifies own state.
5) Go to Search.js and we're going to make it have some state
6) Put header on page with an input

<header>
  <h1> svideo </h1>
  <input type='text' placeholder='Search' />
</header>



-------------- getInitialState() and setState() ---------
1) Now let's give it state
2) ES6 lets you write () instead of function, now put a getInitialState property.

getInitialState () {
    return {
      searchTerm: 'this is the default string'
    }
  },

3) Now have bit of state tracked on search, now just make value of input this.state.searchTerm. Now value of input is always going to correlate to whats in searchTerm
4) Now search input is locked. CAN BE FRUSTRATING
5) Why? Every time you punch a key it kicks off event, React will listen to EVERY event and re-render.
6) Here, NOTHING IS MODIFYING STATE!
7) Have to give input on change listener

<input onChange={this.handleSearchTermChange} value={this.state.searchTerm} type='text' placeholder='Search' />

8) Now make a method called handleSearchTermChange that takes an event, event technically a synthetic DOM event. API is precisely the same.

handleSearchTermChange (event) {
    this.setState({searchTerm: event.target.value})
  },

9) setState will update state object and then kick off another re-render and UI will reflect whatever is in state
10) Can set state with this.forceUpdate(), but shouldn't use. Only time may use is with something like d3




----------------- FILTERING --------------------
1) Arrays also have a filter method that evaluates to T or F, if it's true it stays and if it's F it kicks it out
2) Run it on preload.shows

.filter((show) => {
  return `${show.title} ${show.description}`.toUpperCase().indexOf(this.state.searchTerm.toUpperCase()) >= 0
})

3) Searches titles + descriptions for the search term
4) May need to memoize filter. Using filter inside map is TOTALLY ACCEPTABLE + NORMAL
5) Change searchTerm to an empty string
